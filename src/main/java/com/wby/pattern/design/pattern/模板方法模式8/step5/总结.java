package com.wby.pattern.design.pattern.模板方法模式8.step5;

import java.util.Arrays;

/**
 * Q: 当创建了模板方法,怎么知道什么时候使用抽象方法,什么时候使用钩子?
 * A: 子类必须提供算法中的某个方法或步骤的实现时,就使用抽象方法.
 *     如果算法中的某个部分是可选的,就用钩子.如果是钩子的话,子类可以选择实现这个钩子,但不强制这么做
 * Q: 使用钩子的目的是什么?
 * A: 如上,作用之一是让子类实现算法中的可选部分,或者在钩子对于子类的实现不重要时,子类可以不理会钩子.
 *      另一种用法是,让子类能够有机会对模板方法中某些即将发生的(或刚刚发生的)步骤作出反应:比如,justOrderList()的钩子允许子类在内部列表重新组织后执行某些动作(例如在屏幕上重新显示数据)
 *      钩子也可以让子类有能力为其抽象父类做一些决定.
 * Q: 子类必须实现抽象类中的所有方法吗?
 * A: 是的
 * Q: 是否应该保持抽象方法的数量越少越好,否则,子类中实现这些方法会很麻烦.
 * A: 想做到这一点,可以让算法内的步骤切割的不太细,但是步骤太少的话,会缺少弹性,所以要视情况折中.
 *      记住,某些步骤是可选的,你可以将这些步骤实现成钩子,而不是抽象方法. 这回减轻子类的工作负担
 */
public class 总结 {
}
/**
 * 好莱坞原则
 *
 * 给了我们一种"依赖腐败"的方法. 当高层组件依赖低层组件,而低层组件又依赖高层组件时,高层组件又依赖边侧组件,侧边组建又依赖低层组件时,"依赖腐败"就发生了.
 * 在好莱坞原则下,我们允许低层组件将自己挂钩到系统上,但是高层组件决定"什么时候" 和 "怎么使用" 这些低层组件.换句话说,高层组件对待低层组件是"别调用我们,我们会调用你"
 */
/**
 * 好莱坞原则和模板方法
 *
 * 客户代码只依赖顶级抽象类; 顶级抽象类中能够控制冲泡算法,只有在某些需要子类实现的方法时,才调用子类; 子类只提供一些实现细节(brew() addCondition(),他们如果没有
 * 先被调用,是绝对不会调用抽象类的)
 */
/**
 * Q: 好莱坞原则 和  依赖倒置原则 之间的关系
 * A: 依赖倒置原则 告诉我们避免使用具体类,而使用抽象
 *      好莱坞原则 则是用在创建框架或组件上的一种技巧,好让低层组件能够被挂钩进计算中,又不会让高层组件依赖低层组件
 *      两者都是在于解耦,但是 依赖倒置原则更注重 如何在设计中避免依赖; 好莱坞原则 教我们一个技巧,创建一个有弹性的设计,允许底层结构能互相操作,又防止其他类过于依赖他们
 * Q: 低层组件不可以调用高层组件的方法吗?
 * A: 并不是.事实上,低层组件在结束时,常常会调用从超类中继承来的方法. 我们要做的是:避免明显的环状依赖
 */

/**
 * JAVA API中的模板方法  :  数组类的排序
 */
class Duck implements Comparable{
    private String name;
    private int hetight;


    @Override
    public int compareTo(Object o) {
        Duck otherDuck=(Duck)o;
        if(this.hetight<otherDuck.getHetight()){
            return -1;
        }else if (this.hetight==otherDuck.getHetight()){
            return 0;
        }else {
            return 1;
        }
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getHetight() {
        return hetight;
    }

    public void setHetight(int hetight) {
        this.hetight = hetight;
    }

    public Duck(String name, int hetight) {
        this.name = name;
        this.hetight = hetight;
    }

    @Override
    public String toString() {
        return "Duck{" +
                "name='" + name + '\'' +
                ", hetight=" + hetight +
                '}';
    }
}
class DuckSortTest{
    public static void main(String[] args) {
        Duck[] ducks={new Duck("1",2),new Duck("2",3),new Duck("3",5),new Duck("4",1)};
        System.out.println("排序前");
        display(ducks);
        Arrays.sort(ducks);
        System.out.println("排序后");
        display(ducks);
    }
    public static void display(Duck[] ducks) {
        for (Duck duck : ducks) {
            System.out.println(duck);
        }
    }
}
/**
 * 鸭子排序的内部工作顺序
 *
 * Arrays.sort(ducks): sort方法控制排序的过程,即sort()控制算法,没有类可以改变这点,sort()依赖于一个Compare类提供compareTo()的实现
 *      for(int i=low;i<height;i++){
 *          compareTo()
 *          swap()
 *      }
 * 比较两个鸭子,第一只鸭子的compareTo()被调用,传入另一个鸭子当成比较对象:
 *      ducks[0].compareTo(ducks[1])
 * 如果鸭子的次序不对,就用Array的具体swap()方法将两者对调:
 *      swap()
 * 排序方法会持续比较并对鸭子,知道整个数组的顺序是正确的
 *
 * Duck(compareTo())  与 Arrays(sort() swap()) 没有使用继承,不像典型的模板方法
 */

/**
 * Q: 这真的是一个模板方法吗?
 * A: 这个模式的重点在于提供一个算法,并让子类实现某些步骤.而数组排序做法很明显不是如此,但是要知道,荒野中的API并非总是像教科书例子一样中规中矩,他们总是会为了符合
 *      当前环境和实现的约束 而作出修改.一般,我们无法设计一个类继承java数组,而sort()方法希望能够适用于所有数组(每个数组都是不同的类).所以它定义成为了一个静态方法,
 *      而由被排序的对象内的每个元素自行提供比较大小的算法部分.所以,虽然他不是教科书上的模板方法,但他的视线仍然符合模板方法模式的精神.
 *      再者,由于不用继承就可以使用这个算法,使得排序更有用更具有弹性
 * Q: 排序的实现更像策略模式,为什么要归于模板方法?
 * A: 这么认为的,可能是因为策略模式使用对象组合,某种程度上,可以这样认为: 使用数组对象排序我们的数组,这部分和策略模式很像
 *      但是,策略模式中,所组合的类实现了整个算法.数组实现的排序算法并不完整,他需要一个类填补compareTo()方法的实现,因此它更像模板方法模式
 * Q: java API中还有其他模板方法的例子吗?
 * A: 比如IO类库中的InputStream有一个read()方法,是由子类实现的,而这个方法又会被read(byte b[],int off,int len)模板方法所使用
 */

/**
 * 数组sort()的实现有何优缺点?
 */
/**
 * 另一个模式,他是模板方法的一种特殊情况,源语操作用来创建并返回对象.这是什么模式?
 */
/**
 * 模板方法 与 策略模式
 * C: 我定义一个算法家族,并让这些算法可以互换.因为每个算法都被封装起来,客户可以轻易地使用不同的算法
 * M: 我主要是定义一个算法的大纲,而由我的子类定义其中某些步骤的内容.这样,算法中的个别步骤可以有不同的实现,但是算法的结构依然不会改变.
 *      不过策略模式,你似乎必须放弃对算法的控制
 * C: 我不确定可以这么说,我并不是使用继承进行算法的实现,我是通过组合的方式,让客户可以选择算法的实现
 * M: 但是我对算法更有控制权,而且不会有重复代码.除了少部分外,我的算法每一部分都相同会重复使用到的代码,都被放进了超类中,以便所有子类共享.
 * C: 你或有更有效率一点点,且需要更少的对象.和我采用的委托模型相比,更简单. 但是,我使用对象组合,更有弹性. 客户可以在运行时改变他们的算法
 * M: 是的.但是别忘了,我是使用最多的模式,因为我在超类中提供基础的方法,以便代码复用;并允许子类指定行为.这在创建框架时很有用,
 * C: 但是你的依赖程度比我高
 * M: 怎么说?我的超类是抽象的
 * C: 但是你必须依赖超类中的方法实现,因为这是你算法中的一部分. 而我不同,我不依赖任何人,整个算法我自己搞定
 */

/**
 * 要点
 *  1. 模板方法 定义了算法的步骤,把这些步骤的实现延迟到子类
 *  2. 模板方法模式提供了一种代码复用的重要技巧
 *  3. 模板方法的抽象类可以定义具体方法,抽象方法和钩子
 *  4. 钩子是一个方法,他在抽象类不做任何事,或者只做默认的事,子类可以选择是否覆盖它
 *  5. 为了防止子类修改模板方法,可以将模板方法声明为final
 *  6.好莱坞原则告诉我们,将决策权放在高层模块中,以便决定如何以及何时调用低层模块
 *  7. 真实代码世界看到模板方法模式的许多变化,不要期待是一眼就能认出的
 *  8. 策略模式和模板方法都封装算法,一个用组合,一个用继承
 *  9. 工厂方法 是模板方法的一种特殊版本
 */














