package com.wby.pattern.design.pattern.装饰者模式3.step3;

/**
 * 这就是设计原则5:
 * 我们的目标是允许类容易扩展,在不修改现有代码的情况下,就可以搭配新的行为.如果能实现这样的目标,会有什么好处呢?
 * 这样的设计具有弹性,可以应对改变,可以接受新的功能来应对改变的需求.
 *
 * Q1:对扩展开放,对修改关闭,听起来很矛盾.
 * A1:乍听确实很矛盾,毕竟越难修改的事物,就越难扩展,不是吗?
 *      但是一些OO技巧可以允许系统在不修改代码的情况下进行功能扩展,比如观察者模式,可以在任何时候扩展主题,而不需要向主题中添加代码.
 *
 * Q2:我了解观察者,但是如何设计成为可以扩展,又禁止修改的?
 * A2:许多模式是长期经验的实证,可通过提供扩展的方法来保护代码免于被修改.本章中,将看到使用装饰者模式的一个好例子,完全遵循开放-关闭原则
 *
 * Q3:如何设计让每个部分都遵循开放-关闭原则?
 * A3:通常做不到.要让OO设计同时具有开放性和关闭性,又不修改现有代码,需要花费许多时间和努力.遵循开放-关闭原则通常会引入新的抽象层次,增加代码的复杂度.
 *      你需要集中注意力到设计中最有可能改变的地方,然后应用开放-关闭原则.
 *
 * Q4:怎么知道哪些地方的改变是更重要的呢?
 * A4:涉及到OO系统的设计经验,和你对工作领域的了解.多看一些其他的例子可以帮助你学习如何辨别设计中的变化区.
 */
public class Text {
}
/**
* 认识装饰者模式: 我们已经认识到继承无法完全解决问题,星巴克遇到的问题有:类数量爆炸,设计死板,以及基类中加入的新功能并不适用于所有的子类
 *
 * 所以,这里采用不一样的做法:以饮料为主体,然后运行时使用调料来"装饰"饮料.
 * 比如:顾客想要摩卡和奶泡的咖啡,那么:
 *      1.拿个咖啡对象
 *      2.用摩卡装饰
 *      3.用奶泡装饰
 *      4,调用cost()方法,并依赖委托将调料价格加上去
 * 如何装饰一个对象,而委托如何与此搭配使用呢?把装饰者对象当成包装者
 *
*/
