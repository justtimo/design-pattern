package com.wby.pattern.design.pattern.适配器模式与外观模式7.step3;

/**
 * 适配器模式解析
 *      客户: 客户是依据目标接口(鸭子接口)实现的.  鸭子
 *      适配器: 适配器实现了目标接口,并持有被适配者的实例. 火鸡适配器实现了鸭子接口,并引用了一个被适配者
 *      被适配者: 火鸡
 *
 * 客户使用适配器的过程:
 *      1. 通过目标接口调用适配器的方法,对适配器发出请求
 *      2. 适配器使用被适配者接口把请求转换为被适配者的一个或多个接口
 *      3. 客户接收到调用结果,但并未察觉这一切是适配器再起作用
 *
 * Q: 一个适配器需要做多少"适配"工作?如果我需要实现一个很大的目标接口,会有很多工作要做
 * A: 确实如此,实现一个适配器需要的工作,与目标接口大小成正比.但是不使用适配器,必须改变客户端代码来调用这个新接口,需要做大量的调查工作和代码该写工作
 *      相比之下,提供适配器类,将所有的改变封装在一个类中,是更好的做法
 * Q: 一个适配器只能封装一个类吗?
 * A: 适配器模式是将一个接口转换成另一个.虽然大多数适配器模式采取一个适配器包装一个被适配者,但是也存在需要让一个适配器包装多个被适配者,这涉及另一个
 *      模式:外观模式.人们常常将他们两者混为一谈,后面会进行说明.
 * Q: 如果系统中新旧并存,旧的依旧使用旧的厂商接口,但我们却已经使用新厂商的接口编写了这一部分,该怎么办?
 *      这里使用适配器,那里确使用为包装的接口,这会让人感到混乱.
 * A: 可以创建一个双向的适配器,支持两边的接口.创建双向适配器,就必须实现所涉及的两个接口.这样,这个适配器可以当做旧的接口,或者当做新的接口使用
 */

/**
 * 定义适配器模式
 *      将一个类的接口,转换为客户期望的另一个接口.适配器让原本不兼容的类可以合作无间
 *
 * 这个模式可以通过创建适配器进行接口转换,让不兼容的接口编程兼容.,这可以让客户从实现的接口解耦.如果一段时间后,想要改变接口,适配器可以将
 *      改变的部分封装起来,客户就不必为了应对不同的接口而每次跟着修改.
 * 这个模式有着良好的OO设计原则:使用对象组合,以修改的接口包装被适配者,被适配者的子类也可以搭配着适配器使用
 * 请留意此模式如何将客户与接口绑定起来,而不是与实现绑定起来.我们可以使用多个适配器,每个都转换不同组的后台类,或者加上新类(符合目标接口)
 */
public class Text {
}
