package com.wby.pattern.design.pattern.适配器模式7.step3;

/**
 * 适配器模式解析
 *      客户: 客户是依据目标接口(鸭子接口)实现的.  鸭子
 *      适配器: 适配器实现了目标接口,并持有被适配者的实例. 火鸡适配器实现了鸭子接口,并引用了一个被适配者
 *      被适配者: 火鸡
 *
 * 客户使用适配器的过程:
 *      1. 通过目标接口调用适配器的方法,对适配器发出请求
 *      2. 适配器使用被适配者接口把请求转换为被适配者的一个或多个接口
 *      3. 客户接收到调用结果,但并未察觉这一切是适配器再起作用
 *
 * Q: 一个适配器需要做多少"适配"工作?如果我需要实现一个很大的目标接口,会有很多工作要做
 * A: 确实如此,实现一个适配器需要的工作,与目标接口大小成正比.但是不使用适配器,必须改变客户端代码来调用这个新接口,需要做大量的调查工作和代码该写工作
 *      相比之下,提供适配器类,将所有的改变封装在一个类中,是更好的做法
 * Q: 一个适配器只能封装一个类吗?
 * A: 适配器模式是将一个接口转换成另一个.虽然大多数适配器模式采取一个适配器包装一个被适配者,但是也存在需要让一个适配器包装多个被适配者,这涉及另一个
 *      模式:外观模式.人们常常将他们两者混为一谈,后面会进行说明.
 * Q:
 */
public class Text {
}
