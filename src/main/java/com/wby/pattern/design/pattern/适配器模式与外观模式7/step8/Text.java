package com.wby.pattern.design.pattern.适配器模式与外观模式7.step8;

/**
 * 定义外观模式
 *      提供了一一个统一的接口,用来访问子系统中的一群接口.外观定义了一个高层接口,让子系统更容易使用.
 * 最少知识  原则:只和你的密友谈话
 *  减少对象之间的交互,只留下几个"密友".即: 设计一个系统,不管是任何对象,都要注意他所交互的类有哪些,并注意他和这些类如何交互的.
 *
 * 这个原则希望我们,不要让太多的类耦合在一起,免得修改系统中的一部分,会影响到其他部分.如果许多类相互依赖,那么这个系统变得易碎,且需要花费许多成本维护
 * 究竟怎么才能避免这样呢?这个原则提供了一些方针:任何对象,再改对象的方法内,只应该调用属于一下范围的方法:
 *      1. 该对象本身
 *      2. 被当做方法参数传递进来的对象
 *      3. 此方法所创建或实例化的对象
 *      4. 对象的任何组件
 * 123告诉我们:如果某对象是调用其他的方法的返回结果,不要调用该对象的方法
 * 4告诉我们: 吧组件当成是被实例变量所引用的任何对象.即,把这当成是"有一个"的关系
 *
 * 1234听起来有点严厉,如果调用从另一个调用中返回的对象的方法,会怎么样呢?
 * 如果这么做,相当于向另一个对象的子部分发出请求(而增加我们直接认识的对象数目).
 * 这样,原则要我们改为要对该对象为我们做出请求,这样,我们就不需要认识该对象的组建了(朋友圈子维持在最小状态)
 * 例如:
 *      //不采用此原则
 *      public float getTemp(){
 *          //从气象站取得温度计对象,然后从温度计对象中取得温度
 *          Thermometer Thermometer=station.getThermometer()
 *          return Thermometer.getTemprature();
 *      }
 *
 *      //采用此原则
 *      public float getTemp(){
 *            //应用此原则,我们在气象站加入一根方法,用来向温度计请求温度.这可以减少我们依赖的类的数量
 *            return station.getTemprature();
 *        }
 */
public class Text {
}

/**
 * 讲方法调用保持在界限内
 *  下例是汽车类,展示调用方法的各种做法,同时还能遵守最少知识原则
 */
class Engine{
    public void start(){}
}
class Key{
    public boolean turns(){
        return false;
    }
}
class Doors{
    public void lock(){}
}
class Car{
    //这是类的一个组件,我们能够调用他的方法
    Engine engine;
    //其他实例变量

    public Car() {
        //初始化发动机
    }
    public void start(Key key){
        //创建了一个新对象,他的方法可以直接被调用
        Doors doors = new Doors();
        //当做参数传进来的对象.其方法可以被调用
        boolean authorized = key.turns();
        if (authorized){
            //可以调用组件的方法
            engine.start();
            //可以调用同一个对象内的本地方法
            updateDashboardDisplay();
            //可以调用创建或实例化的对象的方法
            doors.lock();
        }
    }
    public void updateDashboardDisplay(){
        //更新显示
    }
}
/**
 * Q: 还有一个原则叫墨忒尔法则,他和最少知识原则有什么关系?
 * A: 指的是同一个原则,更倾向于使用最少知识原则称呼,因为:1. 名字更直接 2. 法则给人是强制的.
 *      所有原则都应该在有帮助的时候才遵守.所有的设计都需要折中(抽象和速度,空间和时间).
 *      虽然原则提供了方针,但采用原则之前,必须考虑所有的因素.
 * Q: 采用最少知识原则的缺点
 * A: 虽然此原则减少了对象之间的依赖,但是会导致更多的"包装"类被制造出来,以处理和其他组建的沟通,会导致复杂度和开发时间的增加,并降低运行时的性能
 */
