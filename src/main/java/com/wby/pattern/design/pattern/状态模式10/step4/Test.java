package com.wby.pattern.design.pattern.状态模式10.step4;

/**
 * @Auther: LangWeiXian
 * @Date: 2021/10/29 15:25
 * @Description: 现在有新需求: 要给汽水机也装上这套状态游戏
 *
 * 在做新需求之前, 我们看看需要改进什么:
 *  1. 在手出糖果和赢家状态中,有许多重复代码. 可以将State设计成抽象类, 吧默认行为(例如 错误响应)放在其中
 *  2. dipense() 即使没有投币时曲柄被转动的情况下总是会被调用. 我们可以让turnCrank()返回一个布尔值 或 引入异常.
 *  3. 状态转换的所有智能都被放在状态类中,这可能会有什么问题?我们将逻辑移入到糖果机中吗?这么做有什么优缺点?
 *  4. 会实例化许多糖果机吗? 是的话 , 你可能想将状态的实例移到静态的实例变量中共享 ,这需要对糖果机做什么改变?
 */
public class Test {
}

/**
 * 策略模式 与 状态模式 访谈
 * Z: 我在帮类的忙, 让他们在不同的状态中表现不同的行为
 * C: 不, 你是在抄袭我. 你想想: 我允许对象能够通过组合和委托来拥有不同的行为或算法
 * Z: 我们做的事情虽然有关系,但我和你意图不同. 我交客户使用组合和委托的做法完全不同 .
 *      策略模式: 有一个可以实例化的类, 而且通常给他一个实现某些行为的策略对象,就像处理呱呱叫的行为. 真正的鸭子拿到真正的
 *          呱呱叫, 虾皮鸭子拿到吱吱叫
 * C: 是的, 这比你的继承更有威力,对吧?
 * Z: 来看看我的工作吧: 我的Context对象被创建后, 我可以告诉他们从什么状态开始,然后他们会随时间改变自己的状态
 * C: 我也可以在运行时改变行为, 毕竟这是使用组合的目的
 * Z: 但我的做法是利用许多不同的状态对象 ; Context随时间改变状态, 而任何状态改变都是定义好的. 即, "改变行为"是建立在我的方案中的
 * C: 好吧, 我并没有让我的对象拥有一组定义良好的状态转换 , 事实上我会控制我的对象使用什么策略.
 * Z: 看吧, 我们虽然结构相像,但是意图不同.
 */
/**
 * 要点总结
 *  1. 状态模式允许一个对象介于内部状态而拥有不同的行为
 *  2, 和程序状态机(PSM)不同, 状态模式用类来代表状态
 *  3. Context会将行为委托给当前状态对象
 *  4. 通过将每个状态封装进一个类, 我们把以后需要做的任何改变局部化了
 *  5. 状态模式和策略模式有相同的类图, 但是他们意图不同
 *  6, 策略模式通常会用行为或算法来配置Context类
 *  7. 状态模式允许Context随状态改变而改变行为
 *  8. 状态转换可以有State或Context控制
 *  9. 状态模式会导致类数目增加
 *  10. 状态类可以被多个Cotext实例共享
 */
