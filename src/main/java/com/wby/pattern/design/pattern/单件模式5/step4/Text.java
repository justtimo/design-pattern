package com.wby.pattern.design.pattern.单件模式5.step4;

/**
 * Q: 单件模式只有一个类,应该是很简单的模式,但是问题似乎不少
 * A; 固然正确的实现单件模式需要一些技巧,但是当你需要控制实例个数时,还是应该使用单件模式
 * Q: 难道不能创建一个类,所有的方法和变量都定义为静态的,把类直接当做一个单件?
 * A: 如果类自给自足,而且不依赖于复杂的初始化,那么可以这么做.但是因为静态初始化的控制权在Java手上,这么做可能导致混乱,特别是许多类
 *      牵涉其中,这么做会造成一些不容易发现的和初始化次序有关的BUG.
 *      除非你有必要使用类的单件,否则可以建议使用对象的单件,比较保险.
 * Q: 那么类加载器呢?听说两个类加载器可能有机会各自创建自己的单件实例.
 * A: 是的,每个类加载器都定义了一个命名空间,如果有两个以上的类加载器,不同的类加载器可能会加载同一个类.
 *      从整个程序来看,同一个类会被加载多次,如果这事发生在单件上,就会发生多个单件并存的现象.
 *      所以如果程序有多个类加载器又同时使用了单件模式,有一个解决办法:自行指定类加载器,并指定同一个类加载器
 *
 *
 * 谣传垃圾收集器会吃掉单件,这过分夸大了!
 *      1.2之前,垃圾收集器有个BUG,会造成当单件在没有全局的引用时会被当做垃圾清除.
 *      即,单件只有本单件类引用他本身,那么该单件就会被当做垃圾清除.
 *      1.2之后,这个bug已经被修正
 */
public class Text {
}
/**
 * Q: 我知道,类应该做一件事,而且只做一件事,类如果能做两件事,就会被认为不好的OO设计,单件有没有违反这样的观念呢?
 * A: 你说的是"一个类,一个责任"原则.没错,你是对的.单件类不止负责管理自己的实例(并提供全局访问),还在程序中担当角色,所以可以看做两个责任.
 *      尽管如此,由类管理自己的实例的做法并不少见.这可以让整体设计更简单
 * Q: 我想把单件类当成超类,设计出子类,但是遇到了问题:可不可以继承单件类
 * A: 继承单件类会有个问题:构造器是私有的. 你不能用私有的构造器来扩展类,所以必须把单件的构造器改成公开的或受保护的,但是这么做就不是真正的单件了,
 *      因为别的类也可以实例化它;并且还有另外一个问题:单例的实现是利用静态变量,直接继承会导致所有的派生类共享同一个实例变量.
 *      所以,想让子类能工作顺利,基类必须实现注册表功能.这么做之前,你得想想,继承单件类能有什么好处.
 *      可大多数模式一样,单件不一定适合设计进入一个类库中.而且,任何现有的类,都可以轻易地改成支持单件模式.最后,如果你的程序中大量的
 *      使用了单件模式,那么需要检查你的设计,因为通常适合使用单件模式的机会并不多
 * Q: 我还是不了解为什么全局变量比单件模式差
 * A: 全局变量基本上就是对对象的静态引用.这样的情况下,使用全局变量会有一些缺点:急切实例化 VS 延迟实例化.
 *  但是我们要知道这个模式的目的:确保类只有一个实例并提供全局访问,但是不能确保只有一个实例.全局变量也会变相鼓励开发人员,用许多全局变量指向
 *      许多小对象来造成命名空间的污染.单件不鼓励这样的现象,但单件仍然可能被滥用.
 */
