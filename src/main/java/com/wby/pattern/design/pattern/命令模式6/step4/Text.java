package com.wby.pattern.design.pattern.命令模式6.step4;

/**
 * 定义命令模式
 *      命令模式:将"请求"封装成对象,以便使用不同的请求,队列或者日志来参数化其他对象.命令模式也支持可撤销的操作
 *
 *      一个命令对象通过在特定接受者上绑定一组动作来封装一个请求.要做到这点,命令对象将动作和接受者包进对象中.
 *      这个对象值暴露一个execute方法,当此方法被调用时,接受者就会进行这些动作.
 *      从外面看,琪他对象不知道究竟哪个接收者进行了哪些动作,只知道如果调用execute(),请求的目的就能达到
 *
 *      我们也看到了利用命令参数化对象的例子.回到餐厅,服务员一天参数化许多订单.遥控器中,先用"打开点灯"命令加载按钮插槽,又将命令替换为"打开车库"
 *      和服务员一样,遥控器不在乎拥有的是什么命令对象,只要该命令对象实现了Command接口就可以
 *
 *      我们还没说到使用命令模式实现"队列,日志和支持撤销操作",这些是基本命令模式的扩展.一旦有了足够的基础,可轻易地持Meta Command Pattern.
 *      Meta Command Pattern可以创建命令的宏,以便一次执行多个命令
 */
public class Text {
}
/**
 * 命令模式类图
 *      Client 客户负责创建ConcreteCommand,并设置接受者
 *
 *          Client------>ConcreteCommand
 *      Receiver:接受者知道如何进行必要的工作,实现请求,任何类都可以当做接受者
 *      ConcreteCommand:定义了动作和接受者之间的绑定关系.调用者只要调用execute()就可发出请求,然后调用接受者的一个或多个动作
 *          execute():包含了接受者的动作
 *          undo()
 *
 *      Invoker:调用者持有一个命令对象,并在某刻调用命令对象的execute()方法,将请求执行
 *          setCommand()
 *
 *      Command:为所有命令声明一个接口.调用命令对象的execute()方法,就可以让接受者进行相关的动作.这个接口也具备一个undo()方法.
 */

/**
 * A: 就像遥控器中的一样,我们提供一个方法,将命令指定到插槽.实际上我们右个插槽,每个都有"开"和"关"按钮,所以我们用类似方法,将命令指定给遥控器
 *      onCommand[0]=onConmmand;
 *      onCommand[1]=onConmmand;
 * Q: 但电灯对象应该排除.遥控器如何区分客厅或厨房的电灯?
 * A: 遥控器无法区分.除了按下按钮,调用对应命令对象的execute()方法之外,他什么也不知道.
 * Q: 实现时如何确定对象打开/关闭了正确的装置
 * A: 创建命令并将其加载到遥控器时,创建的命令是两个LightCommand,其中一个绑定客厅电灯,另一个绑定厨房电灯.
 *      命令中封装了请求的接受者,所以,按下按钮时,不需要理会打开哪个电灯,只要execute()被调用,该按钮的对应对象就有动作
 */



























