package com.wby.pattern.design.pattern.命令模式6.step1;

/**
 * 命令模式将把封装带到一个全新的世界:把方法调用封装起来.
 * 通过封装方法调用,可以把运算块包装成型,所以调用运算的对象不需要关心如何进行的,只要知道如何使用包装后的方法完成他就行.
 * 通过封装方法调用,可以做一些聪明的事情,比如:记录日志,或者重复使用这些封装来实现撤销
 *
 * A: 命令模式可以将"动作请求者"从"动作执行者"对象中解耦,此例子中,请求者是遥控器,执行者是厂商类其中之一的实例
 * Q: 怎么可能?怎么能将他们解耦?毕竟,按下按钮时,遥控器必须把电灯打开
 * A: 设计中采用"命令对象"就可以办到.利用命令对象,把请求(打开灯)封装成一个特定对象(客厅电灯).所以,如果对每个按钮都存储一个命令对象,那么当按钮被
 *      按下的时候,就可以请命令对象做相关的工作.遥控器并不需要知道工作内容,只要有个命令对象能和正确对象沟通,就可以了.
 *      这样,遥控器和电灯对象解耦了
 */

/**
 * 借助第一章的餐厅理解命令模式
 * 顾客下单createOrder()--->订单:包含了顾客订购的餐点项目---->服务员拿走菜单takeOrder()---->放在柜台,调用orderUp()通知厨师点餐---->厨师做饭makeBurger()
 * 订单封装了准备餐点的请求;服务员接受订单,然后调用订单的orderUp()方法;厨师具备准备餐点的知识
 */

/**
 * 从餐厅到命令模式
 *                                                                         动作和接受者在命令对象中被绑在一起
 * client:createCommandObject()(负责创建命令对象,命令对象包含了接受者上的一组动作)---------------------------------->
 *                                                                                     客户在调用者对象上调用setCommand,把他传入命令对象,该命令对象被存储在其中,以后需要用到
 * command:excute()(命令对象提供一个方法execute,封装了这些动作,调用这个方法会调用接受者的这些动作)------------------------------------------------------------------------->
 *                      某个时刻调用者调用命令对象的execute()                        action1(),action2()
 * Invoker:setCommand()------------------------------------>Command:execute()------------------------>
 *
 * Receiver:action1(),action2() 这导致接受者的动作被调用
 *
 * 加载调用者
 *      1. 客户创建一个命令对象
 *      2. 客户利用setCommand(),将命令对象存储在调用者中
 *      3. 稍后,客户要求调用者执行命令.注意:一旦命令被加载到调用者,该命令可以被使用讴歌并丢弃,或者可以被保留下来并使用多次
 */
public class Text {
}
